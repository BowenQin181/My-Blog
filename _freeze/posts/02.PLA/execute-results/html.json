{
  "hash": "9d5245710fce7706f78b45b8772d861e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 构造感知机模型\ncategories: [R, ML]\ndate: \"2024-03-05\"\n---\n\n\n\n动手实现感知机模型\n\n## PLA\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntheme_set(theme_minimal())\nknitr::opts_chunk$set(\n  out.width = \"80%\",\n  fig.align = \"center\",\n  dev = \"ragg_png\"\n)\n```\n:::\n\n\n\n\n生成线性可分的数据\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nn = 2000\ndf <- tibble(\n  id = 1:n,\n  x1 = rnorm(n),\n  x2 = rnorm(n),\n  y = if_else(2*x1 + 3*x2 >= 0, \"A\", \"B\")\n) %>% \n  arrange(id)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,000 × 4\n      id      x1     x2 y    \n   <int>   <dbl>  <dbl> <chr>\n 1     1 -0.560  -0.512 B    \n 2     2 -0.230   0.237 A    \n 3     3  1.56   -0.542 A    \n 4     4  0.0705  1.22  A    \n 5     5  0.129   0.174 A    \n 6     6  1.72   -0.615 A    \n 7     7  0.461  -1.81  B    \n 8     8 -1.27   -0.644 B    \n 9     9 -0.687   2.05  A    \n10    10 -0.446  -0.561 B    \n# ℹ 1,990 more rows\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf %>% \n  ggplot(aes(x1, x2, color = as_factor(y))) +\n  geom_point(alpha = 0.5) +\n  labs(\n    x = latex2exp::TeX(\"$x_1$\"),\n    y = latex2exp::TeX(\"$x_2$\"),\n    color = \"y\"\n  ) +\n  scale_color_brewer(palette = \"Set2\")\n```\n\n::: {.cell-output-display}\n![](02.PLA_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nml_pla <- function(data, formula, max_time, W = 1) {\n  time <- 0 # 记录运行了几次\n  model_frame <- model.frame(formula, data)\n\n  # 查看Y的分类\n  Y_class <- model.response(model_frame) %>%\n    unique()\n  Y_class_to_number <- c(1, -1)\n  names(Y_class_to_number) <- Y_class\n\n\n  X_matrix <- model.matrix(formula, model_frame)\n  X_ncol <- ncol(X_matrix)\n  W <- rep(W, X_ncol)\n\n  n_errors <- 11111 # 设置一个初始的错误数量，触发下面的条件\n  log_errors <- c() # 记录错误数量\n\n\n\n  while (n_errors > 0 && time < max_time) {\n    # 生成Y的预测值\n    Y_pred <- if_else(sign(X_matrix %*% W) == 1,\n      Y_class[[1]],\n      Y_class[[2]]\n    )\n    \n    # 筛选出分类不正确的数据\n    errors_dt <- model_frame[Y_pred != model_frame[, 1], ]\n    n_errors <- nrow(errors_dt)\n    log_errors <- c(log_errors, n_errors) # 记录错误的数据有多少\n    time <- time + 1\n\n    # 有错误就更新W\n    if (n_errors > 0) {\n      # 随机选出一个错误的点\n      errors_sample_id <- rownames(errors_dt) %>%\n        sample(size = 1)\n      x <- X_matrix[errors_sample_id, ]\n      y <- model_frame[errors_sample_id, 1] %>%\n        as.character() %>%\n        Y_class_to_number[.]\n      \n      # 更新W\n      W <- W + y * x\n    } \n  }\n\n  return(list(\n    pred = Y_pred,\n    \"W\" = W,\n    time = time,\n    log_errors = log_errors\n  ))\n}\n```\n:::\n\n\n\n\n看一下效果\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npla <- ml_pla(df, y ~ x1 + x2, max_time = 10000)\nstr(pla)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ pred      : chr [1:2000] \"B\" \"A\" \"A\" \"A\" ...\n $ W         : Named num [1:3] 0 -26.1 -39.2\n  ..- attr(*, \"names\")= chr [1:3] \"(Intercept)\" \"x1\" \"x2\"\n $ time      : num 1736\n $ log_errors: int [1:1736] 1442 1428 1199 364 449 98 429 368 482 243 ...\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf %>% \n  bind_cols(pred = pla$pred) %>% \n  filter(y != pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 5\n# ℹ 5 variables: id <int>, x1 <dbl>, x2 <dbl>, y <chr>, pred <chr>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "02.PLA_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}