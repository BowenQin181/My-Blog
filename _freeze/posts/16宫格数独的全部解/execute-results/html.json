{
  "hash": "172ff4750ae09f16d89eb68279001223",
  "result": {
    "markdown": "---\ntitle: 4×4 数独的全部解\ncategory: R\ndate: \"2024-05-16\"\ndate-modified: \"2024-05-17\"\n---\n\n\n将0~15填入16宫格中，每行、每列、每条对角线以及每相邻4个数之和都是30\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(arrangements)\n```\n:::\n\n\n# 思路\n\n找出0~15的所有排列方式，计算他们是不是符合要求即可。\n\n但是，0~15的排列方式大约有$2 \\times 10^{13}$种，快速地找出所有排列，筛选符合要求的排列很难。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfactorial(16)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.092279e+13\n```\n:::\n:::\n\n\n先填一半，筛选出符合条件的，\n\n再填后一半，筛选出符合条件的\n\n两半合并\n\n甚至只填出一半就够了\n\n\n\n## 前半段\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfirst_half_comb <- combinations(0:15, 8)\nhead(first_half_comb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    0    1    2    3    4    5    6    7\n[2,]    0    1    2    3    4    5    6    8\n[3,]    0    1    2    3    4    5    6    9\n[4,]    0    1    2    3    4    5    6   10\n[5,]    0    1    2    3    4    5    6   11\n[6,]    0    1    2    3    4    5    6   12\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nperm_mat <- first_half_comb[1, ] %>% \n  permutations()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nperm_mat %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    0    1    2    3    4    5    6    7\n[2,]    0    1    2    3    4    5    7    6\n[3,]    0    1    2    3    4    6    5    7\n[4,]    0    1    2    3    4    6    7    5\n[5,]    0    1    2    3    4    7    5    6\n[6,]    0    1    2    3    4    7    6    5\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrow_sum <- rowSums(perm_mat)\ncol_sum <- colSums(perm_mat)\n```\n:::\n\n\n\n\n### test before perm\n\n要求全部元素之和等于60\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfirst_half_comb <- first_half_comb[rowSums(first_half_comb) == 60, ]\n```\n:::\n\n\n\n\n### 得到排列\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_perm_mat <- function(comb_mats, row_id) {\n  permutations(v = comb_mats[row_id, ])\n}\n\nget_perm_mat(first_half_comb, 1) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    0    1    2    3   12   13   14   15\n[2,]    0    1    2    3   12   13   15   14\n[3,]    0    1    2    3   12   14   13   15\n[4,]    0    1    2    3   12   14   15   13\n[5,]    0    1    2    3   12   15   13   14\n[6,]    0    1    2    3   12   15   14   13\n```\n:::\n:::\n\n\n### 判断排列是否符合要求\n\n最终填入时，按行填入2×4的矩阵，比如\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_perm_mat(first_half_comb, 1)[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0  1  2  3 12 13 14 15\n```\n:::\n:::\n\n\n变成\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_perm_mat(first_half_comb, 1)[1, ] %>% \n  matrix(nrow = 2, ncol = 4, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    2    3\n[2,]   12   13   14   15\n```\n:::\n:::\n\n\n这要求每一行的和都是30，又8个数之和是60，所以只需要第一行的和是30。相邻两列的和也是30，只需1、2列的和与2、3列的和都是30。\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_sat_perm <- function(perm_mat) {\n  sum_row_1 <- rowSums(perm_mat[, 1:4]) == 30\n  sum_col_1_2 <- rowSums(perm_mat[, c(1, 2, 5, 6)]) == 30\n  sum_col_2_3 <- rowSums(perm_mat[, c(2, 3, 6, 7)]) == 30\n  test_res <- rowSums(cbind(sum_row_1, sum_col_1_2, sum_col_2_3)) == 3\n  if (all(test_res == FALSE)) {\n    return(NULL)\n  } else {\n    res <- list(\"perms\" = perm_mat[test_res, ],      # 符合要求的排列\n                \"comb\" = perm_mat[1, ],              # 排列所对应的组合\n                \"diff\" = setdiff(x = 0:15, y = perm_mat[1, ]))  # 可以用来填后一半的数\n    return(res)\n  }\n}\n\nget_perm_mat(first_half_comb, 1) %>% \n  get_sat_perm() %>% \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ perms: int [1:144, 1:8] 0 0 0 0 0 0 0 0 0 0 ...\n $ comb : int [1:8] 0 1 2 3 12 13 14 15\n $ diff : int [1:8] 4 5 6 7 8 9 10 11\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfirst_half_res <- map(1:nrow(first_half_comb),\n           \\(x) get_sat_perm(get_perm_mat(first_half_comb, x)))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfirst_half_res <- first_half_res[!map_lgl(first_half_res, is.null)]\nfirst_half_res %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 91\n```\n:::\n\n```{.r .cell-code}\nstr(first_half_res[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ perms: int [1:144, 1:8] 0 0 0 0 0 0 0 0 0 0 ...\n $ comb : int [1:8] 0 1 2 3 12 13 14 15\n $ diff : int [1:8] 4 5 6 7 8 9 10 11\n```\n:::\n:::\n\n\n虽然从0~15里取八个数有种取法，但是符合要求的取法只有91种，已经极大减少了。不过每种取法还有很多种排列。\n\n## 下一步\n\n思索数据结构\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}